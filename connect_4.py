for main_loop in ["from sys import exit", "def check_input(inp, tests, on = 0, done = -1, **kwargs): return eval({True: 'check_if_passed_all(inp, tests, on + 1, done, **kwargs)', False: 'incorrect_input(tests, done, **kwargs)'}[eval(tests[on].format(inp=inp, **kwargs))])", "def check_if_passed_all(inp, tests, on = 0, done = -1, **kwargs): return eval({True: 'inp', False: 'check_input(inp, tests, on, done, **kwargs)'}[on == done or on == len(tests)])", "def incorrect_input(tests, done, **kwargs): return check_input(input('Input was invalid.  Please enter again. '), tests, 0, done, **kwargs)", "y = int(check_input(input('How tall should the board be? '), ['\"{inp}\".isdigit()', '{inp} > 0']))", "x = int(check_input(input('How wide should the board be? '), ['\"{inp}\".isdigit()', '{inp} > 0']))", "record = [0, 0, 0]", "def get_place(player, stacks): return int(check_input(input(f\"Player {player}\\\'s ({('X', 'O')[player - 1]}) move: \"), ['\"{inp}\".isdigit()', '0<={inp}<{x}', '{stacks}[int({inp})]<{y}'], stacks=stacks, x=x, y=y))", "draw_line_coms = ['printing = []','for x_val in range(x): printing.append({None: \" \", 1: \"X\", 2: \"O\"}[board.get((x_val, line))])', 'print(\"|\" + str(printing).replace(\"\\\', \\\'\", \"|\")[2:-2] + \"|\")']", "def draw_line(line, board): exec('for draw_line_exec in draw_line_coms: exec(draw_line_exec)')", "draw_board_coms = ['print(str([x_val for x_val in range(x)]).replace(\" \", \"\"))','lines = [line for line in range(y)]','lines.reverse()', 'for line in lines: draw_line(line, board)']", "def draw_board(board): exec('for draw_board_exec in draw_board_coms: exec(draw_board_exec)')", "game_coms = ['board = dict()', 'stacks = [0 for stack in range(x)]', 'player = int(check_input(input(\"Which player should go first? (1, 2) \"), [\"\\\'{inp}\\\'.isdigit()\", \"0<{inp}<=2\"]))', 'draw_board(board)', 'info = [0, True, player, 0]', 'while info[1] and info[0] < (x * y): single_loop(info, board, stacks)', 'record[info[3]] += 1', 'print(f\"Game over on turn {info[0]}.\")']", "def game(): exec('for game_exec in game_coms: exec(game_exec)')", "def check_dir(board, at_x, at_y, vector, wanted): return eval({True: '1 + check_dir(board, at_x + vector[0], at_y + vector[1], vector, wanted)', False: '0'}[board.get((at_x, at_y), 3) == wanted])", "def collapse_nums(list): return [list[num] + list[num + int(len(list)/2)] for num in range(int(len(list)/2))]", "def check_win(board, at_x, at_y, player): return max(collapse_nums([check_dir(board, at_x, at_y, vector, player) for vector in [(1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1), (0, -1), (1, -1)]])) > 4", "single_loop_coms = ['info[0] += 1','print(f\"Turn {info[0]}.\")', 'place = get_place(info[2], stacks)', 'board[(place, stacks[place])] = info[2]', 'draw_board(board)', 'exec({True:\"info[1] = False\", False:\"info[2] = (info[2] % 2) + 1\"}[check_win(board, place, stacks[place], info[2])])', 'exec({True: \"pass\", False: \"info[3] = info[2]\"}[info[1]])', 'stacks[place] += 1']", "def single_loop(info, board, stacks): exec('for single_loop_exec in single_loop_coms: exec(single_loop_exec)')", "loop_coms = ['game()', 'print(f\"You have tied {record[0]} time(s).\")', 'print(f\"Player 1 has won {record[1]} time(s).\")', 'print(f\"Player 2 has won {record[2]} time(s).\")', 'exec({True: \"pass\", False: \"exit()\"}[input(\"Would you like to play again? (Y/N) \") == \"Y\"])']", "def loop(): exec('for loop_exec in loop_coms: exec(loop_exec)')", "while True: loop()"]: exec(main_loop)